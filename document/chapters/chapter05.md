# 마이크로 서비스의 통신 구현 

## 1. 이상적인 통신 구현 전 신경써야하는 것들

### 하위 호환성
- 마이크로 서비스를 변경할 때에는 호환성이 깨지지 않도록 주의해야한다.
- 필드를 추가하는 등의 간단한 작업으로 클라이언트의 서비스가 지장이 가도록 하면 안된다.
- 운영하기 전에 다른 마이크로 서비스와의 호환성을 테스트해야한다.

### 명시적인 인터페이스
- 노출되는 마이크로 서비스의 기능이 소비자에게 명확하게 전달되지 않아 호환성을 깨지게 될 수 있다.
- 어떤 기능이 유지되고 어떤 기능이 변경되는지 개발자에게 명확하게 전달되어야 한다.
- 스키마를 명시적으로 정의하고 문서화하는 방법도 효과적이다.
- 어떤 기술을 사용하든 기능을 충분하게 설명하는 문서와 함께 제공해야한다.

### 기술 중립적인 API 사용
- 기술의 변화에 따라 우리가 사용하는 기술이 변화할 수 있기 때문에 기술 중립적인 API를 사용하는 것이 중요하다.
- 특정 기술 스택을 강요하는 API를 사용하게 될 경우 기술 스택이 변경될 때에는 모든 마이크로 서비스를 변경해야될 수도 있다.
- 특정 API에 종속되게 되어 상황에 맞는 기술스택을 선택하기 어려운 상황은 피해야한다.

### 단순한 서비스 설계
- 클라이언트가 마이크로 서비스를 사용하는데에 비용이 증가하게 된다면 아름다운 마이크로 서비스의 설계는 실패라고 말할 수 있다.
- 마이크로 서비스의 설계는 단순하고 사용하기 쉬워야한다. 
- 클라이언트는 기술을 사용하는데에 있어서 완전히 자유로워야한다.
- SDK를 제공해주는 방법들도 존재하지만 결힙과 비용이 증가하게 되는 것은 감수해야한다.

### 내부 구현 숨기기
- 이전에 설명했듯이 정보의 은닉은 중요하다. 
- 소비자가 내부 구현을 알고 있다는 것은 의존하고 있다는 것을 의미하며 이는 결합을 높이게 된다.
- 이는 변경비용을 증가시킴으로써 마이크로 서비스의 변경을 어렵게 만든다.
- 기술부채를 증가시키지 않도록 내부 구현의 상세 정보를 노출하는 기술은 피해야한다.

## 2. 기술 선택
다양한 기술을 선택할 수 있지만 대표적으로는 아래의 기술들을 뽑을 수 있을 것이다.
- 원격 프로시저 호출(RPC): 대표적으로 gRPC와 SOAP가 있으며 원격에 있는 프로세스에서 메서드를 호출하는 방식이다.
- REST: HTTP를 통해 데이터를 주고 받는 방식으로 가장 대중적으로 사용되는 방식이다.
- 그래프 QL: 페이스북에서 만든 쿼리 언어로 클라이언트가 필요한 데이터를 요청하는 방식이다.
- 메시지 브로커: 레빗엠큐나 카프카와 같은 큐와 토픽을 통해 메시지를 주고 받는 방식이다.

### 원격 프로시저 호출
- 로컬 호출을 통해 원격에 있는 프로세스에 있는 서비스를 실행하는 기술이다.
- 명시적인 스키마를 필요로 하며 보통 인터페이스 정의 언어(IDL)나 웹 서비스 설명 언어(WSDL)를 사용한다.
- 자바의 RMI, .NET의 WCF와 같은 기술은 다른 기술과 달리 강한 결합을 요구한다.
- 일반적으로 RPC 기술을 사용한다는 것은 직렬화 프로토콜을 사용한다는 것을 의미한다.
- 구현체마다 TCP나 UDP와 같은 프로토콜을 사용하는데에 있어서 제한이 있을 수 있다.
- 명시적인 스키마가 있는 RPC를 사용하면 클라dl언트 코드를 생성하기 쉽다. 하지만 이를 위해서는 호출하기 전 스키마를 액세스 할 수 있어야한다.
- 클라이언트 코드를 생성하여 평소처럼 사용한다는 것에 있어서 큰 장점으로 볼 수 있다.

#### 문제점
- 기술 결합 발생
  - 자바 RMI나 .NET WCF와 같은 기술은 특정 기술에 종속되어 있기 때문에 다른 기술로 변경하기 어렵다.
  - RPC는 종종 상호 운영성에 대한 제약이 있을 수 있다.
  - 어떤 면으로 보면 내구 기술의 구현을 노출하는 형태로 볼 수 있다.
- 오버헤드 발생
  - 메서드를 호출하는 것처럼 보이지만 네트워크를 통해 호출하기 때문에 오버헤드가 증가할 수 밖에 없다.
  - 페이로드를 직렬화하고 역직렬화하는 과정이 필요하기 때문에 추가적인 비용이 발생한다.
  - 지나친 추상화를 통해 개발자가 네트워크를 이해하지 못하고 사용하는 경우가 종종 있다.
  - 서버는 기본적으로 외부의 네트워크를 신뢰할 수 없다. 네트워크는 느리거나 실패할 수도 있고 패킷이 변경될 수 있기 때문이다.
- 깨지기 쉽다. 
  - 고객이라는 정보를 가져올 때 이름, 주소, 전화번호, 메일을 가져오는 것을 예로 들어보자.
  - 메일이라는 정보가 사용되지 않는 상황이여서 필드를 삭제한다고 가정해보자.
  - 이렇다면 서버에서 필드를 제거하면서 클라이언트에 있는 역직렬화 코드가 깨지게 된다. 
  - 해당 변경사항을 운영에 배포하려면 서버와 클라이언트를 동시에 변경해야된다.(락스탭 릴리즈)
  - 이는 확장만 가능한 객체들을 만들게 되는 것을 의미하며 더이상 사용되지 않더라도 삭제할 수 없게 된다.
#### 주의점
- RMI와 같은 RPC는 기술스택에 종속되게 만들며 SOAP와 같이 사용하기에는 무거운 기술들도 존재한다.
- 네트워크가 완전히 숨겨질정도로 추상화를 하지 않는 것이 좋고 클라이언트와 서버가 같이 배포되지 않고 인터페이스를 개선할 수 있도록 하는 것이 좋다.
- 현재까지는 gRPC가 가장 좋은 선택지로 보인다. 서버₩와 클라이언트가 양방향 스트리밍을 지원하며 HTTP/2를 사용하기 때문에 성능이 좋다.

## REST
- HTTP를 통해 데이터를 주고 받는 방식으로 가장 대중적으로 사용되는 방식이다.
- REST에서는 리소스의 개념을 통해 데이터를 수정하거나 특정한 프로세스를 처리하는 등의 작업을 수행한다.
### REST와 HTTP
- HTTP Method를 통해 리소스를 행동에 대해 정의한다.
- 거대한 생태계를 이루고 있기 때문에 수많은 모니터링, 보안, 로깅, 캐싱, 로드밸런싱과 같은 기능을 사용할 수 있다.
- HTTP를 잘 사용한다면 그 혜택들을 받을 수 있겠지만 잘못 사용한다면 안전하지도 않을뿐더러 확장하기도 어려워진다.
- RPC도 HTTP를 사용하지만 HTTP 명세를 따르지 않기 때문에 REST와는 다르다고 볼 수 있다.

### 애플리케이션 상태 엔진으로서의 하이퍼미디어
- 하이퍼미이어를 사용한 어플리케이션 상태 엔진
- 클라이언트는 서버가 어디에 존재하고 어떻게 동작하는지 알 필요가 없다.
- 클라이언트는 필요한 것을 찾기 위해 하이퍼미디어를 사용하면 된다.
- 네이버에서 검색해서 쇼핑을 하고 싶다면 하이퍼링크를 통해 쇼핑몰 사이트로 이동하면 된다.
- 이러한 방식은 하나의 서비스처럼 보이지만 하이퍼링크를 통해 다른 서비스로 이동하게 되면서 개념적으로 완전히 분리함은 물론이고 성능이 저하되지 않는다.

### 문제점
- 클라이언트와 서버간의 결합성이 생기는 문제가 발생한다. 
- 일반적으로는 Json과 같은 문자 포맷을 TCP 연결을 통해 데이터를 주고 받는데 이는 성능의 저하를 가져올 수 있다.
- HATEOAS는 클라이언트가 원하는 엔드포인트를 찾기 위해 여러번의 왕복 호출이 발생할 수 있어 성능이 저하될 수 있다.
- 하지만 HTTP 기반 REST는 가장 널리 알려져 있는 방식이기 때문에 다양한 기술들을 지원받아 사용할 수 있기 때문에 합리적인 선택지로 볼 수 있다.

### 적용 대상
- 동기식으로 다양한 서비스를 호출해야되는 경우에는 REST가 적합하다.
- REST 기반 비동기 API를 구축할 수 있지만 다른 대안들을 비교해봤을 때 그다지 좋은 선택지는 아니다.
- HATEOAS는 현재 시스템의 모델이 적합하지 않는다면 사용하기 어렵다.

## 그래프 QL
- 그래프 QL은 클라이언트가 동일한 정보를 검색할 때 여러번 요청할 필요가 없이 한번의 요청으로 모든 정보를 가져올 수 있다.
- 그런 부분에 있어 클라이언트 측에서 성능이 상당히 향상되었따.
- 필요한 정보만 가져오는 단일 쿼리를 사용하기 때문에 불필요한 호출을 줄이고 데이터 양을 줄일 수 있다.

### 문제점
- 클라이언트의 요청에 따라 서버에서 데이터를 가져오는 방식이기 때문에 서버에 부하가 발생할 수 있다.
- 그래프 QL 자체에서 문제가 있는 쿼리를 작성하는 것에 대해 추적하기 어렵다.
- 데이터를 동적으로 가져오기 때문에 캐싱을 통한 성능 향상이 어렵다.
- 데이터로 작업하는 것처럼 느껴져 데이터베이스의 래퍼처럼 사용될 수 있다.

### 적용 대상
- 외부 API를 여러번 호출해야되는 경우에는 그래프 QL이 적합할 수 있다.
- 집계 및 필터링이 주요 메커니즘이므로 하위 시스템에서 데이터를 가져오는 것이 적합할 수 있다.
- 그래프 QL의 대안으로 BFF 구조를 사용할 수 있다.

## 메시지 브로커
- 미들웨어처럼 프로세스 사이에 중개자로 강력한 기능들을 비동기 통신을 구현하는 선택지로 인기가 많다.
- 메시지 브로커는 요청과 응답 뿐만 아니라 이벤트 등의 다양한 메시지를 전달할 수 있다.
### 토픽과 큐
- 발신자는 큐에 메시지를 넣고 소비자는 해당 큐에서 메시지를 읽는다.
- 큐는 하나의 소비자에게 전달되어 소비되며 하나의 그룹에게만 수신이 된다.
- 토픽은 큐와 달리 여러개의 소비자 그룹을 가질 수 있고 메시지를 브로드캐스트 할 수 있다.
- 토픽은 이벤트 기반 통신에 적합하고 큐는 요청과 응답 통신에 더 적합하다.

### 전달 보장
- 브로커를 사용하는 이유는 전달 보장이라는 약속을 가지고 메시지를 전송하기 때문이다.
- 다운 스트림 서비스에서 신경써야하는 작업의 수들이 줄어든다.
- 보통의 브로커는 고장나더라도 메시지가 손실되지 않도록 구축되어 있다.
- 브로커를 얼마나 신뢰할지 결정하여 적절한 아키텍처를 구축해야한다.
- 브로커들은 정확히 한번을 전송하는데 발전을 해왔으며 이런 부분은 소비자가 메시지를 처리하는데 신뢰성을 올려준다.

### 카프카
- 스트림 프로세싱 파이프라인을 구현함으로써 대용량의 데이터를 처리하거나 실시간으로 데이터를 처리하는데 매우 특화되어 있다.
- 카프카는 여러 소비자와 생산자를 허용하도록 만들어 졌다.
- 카프카의 메시지는 영속성을 가지고 있으며 수신하지 않으면 메시지가 손실되지 않는다. 
- 하지만 무작정 전송에 실패한 메시지를 저장하고 무기한 저장하면 자원의 낭비이기 때문에 KSQL과 같은 스크립트로 카프카의 상태나 메시지를 조횔 할 수 있다.

## 직렬화 포맷
### 텍스트 포맷
![img.png](../images/avro.png)
- Json이나 XML과 같은 표준 텍스트 포맷을 사용하면 클라이언트가 자원을 사용하는 방법에 있어서 유연하게 가져갈 수 있다.
- Json은 XML보다 훨씬 더 압축하기 쉽기 때문에 페이로드로 인해 많은 사람들이 채택했고 표준적으로 많이 사용하고 있다.
- 스키마를 기반으로 구조를 정의하는 아브로도 흥미로운 구조 중 하나이다.

### 바이너리 포맷
- 페이로드의 크기나 쓰기, 읽기의 효율을 고려하면서 gRPC와 같은 곳에 자주 사용됨
- 전송을 마이크로 단위로 줄일려면 다양한 포맷을 직접 사용해보면서 비교하는 것을 권장
- 데이터를 줄이거나 호출하지 않는 방법이 제일 이상적이다.

## 스키마
- XML은 XSD를 사용하며 JSON으로 작업한다면 JSON tmzlakfmf tkdydgksek.
- SOAP는 WSDL로 동작하고 gRPC는 버퍼 명세가 필요하다.
- 명시적 스키마를 사용하는 것은 필요한 양의 문서를 줄이는데 많은 도움이 된다.

### 구조적 계약 위반과 의미적 계약 위반
- 구조적 계약 위반은 소비자가 호환되지 않는 방식으로 엔드포인트가 변경되는 상황(필드 제거나 변경)
- 의미적 계약 위반은 구조는 동일하지만 소비자가 기대한 것과 다른 방식으로 동작할 때

### 스키마를 사용해야하는 이유
- 동적 언어는 컴파일의 안정성을 포기하고 많은 이점을 제공하지만 마이크로 서비스 입장에서는 그러한 이점 상쇄된다.
- 동적 언어에서도 명시적 스키마를 사용하지 않고 사용한다면 어떻게 테스트하고 구조적 계약을 준수하고 있다고 보장할 것인가?
- 마이크로 서비스에서 무엇을 노출할지와 노출하지 않는지 명시적으로 표현하는 것이 중요하다.

## 마이크로 서비스간 변경 처리
- 마이크로 서비스간 버전을 관리하는 체계와 중단 없이 계약을 변경하는 방법에서 가져야할 요소는 아래와 같다.
1. 확장 변경  
계약에서 새로운 것만 추가하고 제거하지 않는 것


2. 관대한 독자
```xml
<customer>
  <firstname>lee</firstname>
  <lastname>yongseon</lastname>
  <email>test@gmail.com</email>
  <phoneNumber>010-1234-1234</phoneNumber>
</customer>
```
소비자는 이름, 성, 이메일 필드만 필요하고 나머지는 필요없다. 하지만 소비자는 모든 필드를 직렬화하면서 문제를 일으킬 수 있는데
이는 나중에 휴대폰 번호가 변경되지 못하고 소비자가 중지되게 만든다.
```xml
<customer>
  <naming>
    <firstname>lee</firstname>
    <lastname>yongseon</lastname>
  </naming>
  <email>test@gmail.com</email>
</customer>
```
클라이언트에 최대한 유연하게 사용할 수 있도록 구조를 설계하여 변경사항은 무시할 수 있는 **관대한 독자**가 되도록 하자.
당신이 하는 일에는 엄격하고 남에게 하는 일은 관대해야한다.

5. 올바른 기술  
인터페이스 변경에 유연한 기술을 사용하여 클라이언트에 중단없이 사용할 수 있도록 하자.
아브로는 명시적인 스키마를 전달하고 페이로드를 전달하고 gRPC는 프로토콜 버퍼 자체에 필드 번호 개념을 가지고 있기 때문에 괜찮다.


4. 명시적 인터페이스
- 소비자를 중단시키지 않으려면 어떤 필드를 건드려야하는지 모든 개발자들이 이해할 수 있도록 명시적으로 스키마를 정리해야한다. 
- OpenAPI Specification을 통해 REST 엔드포인트를 명시적으로 사용할 수 있도록 되었다.
- 이벤트 또한 CNCF나 CloudEvents와 같이 명세하는 표준들이 생겨나고 있다.

5. 우발적 중단 일찍 발견하기
- 구조적 중단 같은 경우는 스키마의 변경을 비교하여 확인하는 도구들이 많이 나외있다.(프로토락, json-schema-diff-validator, open-api-diff 등)
- 스키마 비교 도구는 구조적 계약 위반을 알아채는데 큰 도움을 주지만 의미적 계약 위반을 도와주지는 못한다.
- 계약 테스트와 소비자 주도 계약을 통해 풀 수 있지만 나중에 좀 더 알아 보자


## 중단 변경 관리
하위 호환성을 유지하기 위해 최대한 노력했더라도 때로는 중단 변경이 필요한 순간이 오게된다. 그럴 때 대표적으로 선택되는 선택지들은 아래와 같다.
1. 락스텝 배포: 인터페이스를 노출하고 있는 마이크로 서비스와 소비자들을 모두 같이 배포
2. 호환되지 않는 마이크로서비스의 공존: 마이크로 서비스에서 기존 버전과 신규 버전을 나란히 실행
3. 기존 인터페이스 에뮬레이터: 새 인터페이스와 기존 인터페이스를 같이 노출하도록 개발


### 락스텝 배포 
락스텝 배포는 마이크로서비스의 특성 중 독립적인 배포와 대치되기도 한다.
만약 당신이 독립적인 배포의 특성을 띄고 싶다면 소비자에게 새 인터페이스로 변경하는 시간을 주어야한다.

### 호환되지 않는 마이크로서비스와의 공존
![img.png](../images/마이크로서비스_공존_예시.png)
- 이전 인터페이스를 소비하는 소비자는 이전 서비스로 라우팅하고 새로운 인터페이스를 사용하는 소비자는 새로운 마이크로서비스에 라우팅하는 전략
- 소비자가 오래된 마이크로 서비스를 지속적으로 사용해야할 때 드물게 사용하는 전략이다.
- 내부적으로 수정해야하는 버기가 존재할 경우 서로 다른 서비스를 수정하여 같이 배포해야한다.
- 소비자가 단순하게 마이크로 서비스를 사용하는데 지장을 준다. 중간에 nginx가 존재하여 시스템 동작의 이해를 어렵게 만들고 서로 다르게 버전을 관리하면서 
하나의 엔티티의 모든 서비스에 존재하지만 서로 다른 서비스에 동작하게 되면서 복잡도를 높이게 된다!
- 카나리아 배포와 같은 단기간내에 공존해야되는 상황이 필요할 때에는 사용이 가능하지만 버전이 업그레이드하는데 시간이 오래걸릴수록 다른 전략을 찾는 것이 좋다.

### 기존 인터페이스 애뮬레이션
- MSA는 독립적으로 배포되길 원하며 변경으로 인해 발생하는 영향을 제한하는 것을 권장하고 있다.
- 하위호환성을 깨트리고 배포전략은 독립적으로 가져가고 싶다면 레거시 인터페이스와 신규 인터페이스를 같이 두면된다.
- 이런 방법은 중단없이 새로운 마이크로서비스를 배포할 수 있고 빠르게 배포할 수 있게된다.
![img.png](../images/기존%20인터페이스%20예시.png)
- 위의 그림과 같이 기존의 인터페이스와 신규 인터페이스를 동시에 제공하다가 모든 소비자가 인터페이스가 변경이 되었다면 이전의 인터페이스는 제거가 된다. 
- 버저닝을 통해서 인터페이스를 관리했지만 기존의 인터페이스와 신규 인터페이스를 모두 동작하다는 테스트가 필요했기에 추가적인 부담은 증가하게된다.
- 두개의 인터페이스를 동시에 제공하는 것은 부담이되었기에 V1에 필요한 인터페이스를 V2에 분기를 나뉘어 제공하고 V3에서 레거시 코드베이스를 완전히 제거하면서
비교적 손쉽게 제거할 수 있었음(확장/축소 패턴)
- RPC는 좀 더 까다로울 수 있지만 `v1.createUser`, `v2.createUser`와 같은 방식을 사용하여 처리했지만 동일한 타입에 대해 처리할 때에는 어려움이 큼

### 어떤 방식을 선호하는가?
- 락스텝 배포
  - 단일팀이 관리하며 일회성으로 배포가 되어야할 때
  - 락스텝이 잦으면 분산형 모놀리식 아키텍처가 된다.
- 인터페이스의 공존
  - 짧은 시간 동안 다른 인터페이스를 제공해야할때
  - 현실적으로는 몇주이상 소요가능성이 있음
  - 블루 그린 배포나 카나리아에 유리한 전략

## 사회적 계약
- 이전 인터페이스를 계속 사용하고 유지하는 것은 지속적인 비용을 증가시키기 때문에 가능한 빨리
  기존 인터페이스의 코드와 인프라를 제거하고 새로운 인터페이스를 사용하도록 변경해야 한다.
- 마이크로서비스에서 하위호환이 되지 않는 변경은 마이크로서비스의 관리자와 소비자 등 모든 이해관계자들이
  사전에 합의하지 않고 변경했을 때 온갖 문제가 발생할 수 있다.
- 마이크로서비스는 소비자가 호출하기 위해 존재하며 소비자에게 문제를 일으킬 수 있는 마이크로 서비스에 대해 변경하는 경우를 반드시 고려해야한다.
- 어떤 상황에서는 소비자가 변경이 불가능할 수 있으니 트레이드 오프를 잘 고려해야한다.
### 인터페이스 변경에 대해 논의해야되는 것
- 인터페이스를 변경해야하는 이슈에 대해서는 어떻게 제기할 것인가?
- 소비자와 마이크로서비스 관계자가 변경에 동의하도록 어떻게 협의해야되는가?
- 소비자가 변경된 인터페이스에 대한 작업을 수행하는 자 선정
- 소비자가 인터페이스를 전환하는데까지 걸리는 시간

## 사용성 추적
- 이해관계자들이 모두 동의하여 인터페이스가 중단되었다고 하더라도 미처 고려하지 못한 사용자가 있을 수 있다.
- 엔드포인트를 접근할 때 로그인을 보장하는 것을 통해 어떤 사용자가 접근하는지에 대한 추적을 할 수 있다.
- 그렇게 되면 모든 소비자들이 새로운 인터페이스로 전환할 수 있도록 손쉽게 도와줄 수 있다.


## 극단적 조치
- 이전에 제공하고 있는 인터페이스에 대해 사전협의가 되었음에도 불구하고 소비자가 적극적으로 도움을 주지 않는 경우도 있다.
- 어떤 소비자가 해당 인터페이스를 사용하는지에 대해 추적이 안되는 상황이라면 어쩔 수 없이 극단적인 조치를 취해야 할 수도 있다.
- 이러한 경우에는 소비자에게 더 이상 인터페이스를 제공하지 않는 방법이 존재한다. 이는 많은 비효율과 비용이 발생할 수 있으므로 극단적인 조치로서 사용해야한다.
- 아니면 해당 인터페이스를 제공하고 있는 API의 지연시간을 계속 증가시켜 다른 팀이 새로운 인터페이스를 사용하도록 유도하는 방법도 있다.

## 마이크로 서비스에서 DRY 원칙의 위험성
- DRY(Don't Repeat Yourself) 원칙은 코드의 중복을 피하고 코드의 재사용성을 높이기 위한 원칙이다.
- 코드 중복의 단점
  - 기존 코드 베이스가 거대해져 유지보수가 어려워진다.
  - 같은 동작을하는 코드가 여러곳에 존재하기 때문에 변경이 필요할 때 모든 곳을 변경해야한다.
  - 코드의 중복이 많아질수록 버그가 발생할 확률이 높아진다.
- 중복된 코드를 모아서 추상화 시킨다음 공통 모듈로 만들어서 사용하면 중복을 피할 수 있다.

### 라이브러리를 통한 코드 공유
- 마이크로서비스에서 가장 피해야되는 것은 소비자의 너무 강한 결합으로 인해 작은 변경에도 소비자에게도 영향을 미치는 것이다.
- 공통으로 사용하는 도메인 모델이나 라이브러리로 인해 모든 서비스가 변경되어 유효하지 않은 메시지를 비워야 했으며 이를 잊어버리면 큰 문제가 발생했었다.
- 라이브러리 형태로 사용했을 때 모든 마이크로 서비스는 변경할 수 없다는 것과 각기 다른 버전을 쓸 수 있는 것을 받아들여야한다.

### 클라이언트 라이브러리
- 서비스를 위한 클라이언트 라이브러리를 사용하여 변경에 비교적 자유로울 수 있으며 중복을 피할 수 있다.
- 서버를 위한 클라이언트 라이브러리를 만들 때 같은 사람이 만들면 안되는 것을 권장한다.
- 클라이언트 라이브러리를 만들 때 AWS의 모델 중 하나를 참고하여 사용하는 것도 좋은 방법이다.
- 넷플릭스의 클라이언트 라이브러리는 안정적인 서비스와 확장적인 서비스를 만드는데 도움을 많이준다.(로깅, 디스커버리, 실패 모드 등)
- 클라이언트 라이브러리를 고려하고 있다면 서비스와 독립적으로 공통적으로 사용하는 기능을 라이브러리로 만들어 사용하는 것이 좋다.

## 서비스 디스커버리
- 다수의 마이크로서비스가 존재할 때 우리는 마이크로서비스의 위치나 모니터링 등을 필요로 하게 된다.
- 이처럼 마이크로서비스의 위치를 관리하거나 모니터링하는 분야를 통틀어 서비스 디스커버리라고 한다.
- 서비스 디스커버리의 솔루션 종류
  - 인스턴스가 스스로 등록하는 방식
  - 등록된 서비스를 찾아서 사용하는 방식

### 도메인 네임 시스템(DNS)
- 가장 간단한 방법으로 서비스 디스커버리를 구현하는 방법이다.
- 보통 관례를 기반으로 `서비스 이름`.`도메인`으로 서비스를 등록하여 사용한다.
  - 예를 들어 `orders.netflix.com`과 같은 방식으로 사용한다.
- DNS 엔트리를 관리하는데 익숙하고 DNS 서버를 사용하는데 익숙하다면 DNS를 사용하는 것이 좋은 해결책이다.
#### DNS의 단점
- TTL(Time To Live)이라는 시간이 존재하는데 이 시간이 지나면 DNS 서버에 캐시된 정보가 만료되어 새로운 정보를 가져와야한다.
- DNS는 TTL이 모두 만료될 때까지 오래된 엔트리를 유지해야하고 캐싱되는 구간이 많을수록 오래된 엔트리가 더 많이 유지된다.
- 로드밸런서를 통해 새로운 서비스 인스턴스로 보내게 되면 해결되지만 중간에 하나의 인스턴스가 죽었을 때 트래픽 라우팅을 중단하기 어려워 심각한 문제로 이어질 수 있다.
- 하나의 인스턴스를 쓴다면 DNS를 써도 되지만 여러 인스턴스를 쓴다면 로드밸런서를 통해 확인하도록 하자

## 동적 서비스 레지스트리
- 인스턴스가 동적으로 생성되고 폐기되는 환경에서는 DNS를 사용하는 것이 적합하지 않다.
- 중앙에 서비스 레지스트리를 두고 서비스 인스턴스가 등록하고 조회하는 방식을 사용하는 것이 등장하여 여러 기술들이 경쟁하고 있다.

### 주키퍼
- 하둡, 메시지큐, 데이터 동기화등 많은 곳에서 사용되는 기술이다.
- 안전하게 동작할 수 있도록 최소 3개의 서버를 두고 클러스터를 구성하도록 되어있다.
- 주키퍼는 계층적 네임스페이스를 가지고 있고 이를 통해 동적으로 서비스를 등록하거나 로그 레벨을 변경하는 등의 작업이 수행 가능하다.

### 콘술
![img.png](../images/SRV%20레코드%20예시.png)
- REST API를 통해 서비스를 등록하고 조회하는 방식을 사용한다.
- 자체 DNS 서버를 가지고 있어서 SRV 레코드를 통해 서비스를 조회할 수 있다.
- 텍스트 기반으로 작성된 콘술 템플릿을 사용하여 항목을 업데이트할 수 있다.

### etcd와 쿠버네티스
- 파드에 컨테이너를 배포하고 포드와 관련된 메타 데이터의 패턴 매칭을 통해 서비스를 찾을 수 있다.
- 서비스에 대한 요청이 들어왔을 때 해당 포드로 라우팅하는 방식을 사용한다.
- 쿠버네티스라는 환경에 매혹되어 콘술을 보지않는 것은 좋은 선택이 아니다. 쿠버네티스 환경과 다른 환경이 혼합되어 있는 환경에서는 두플랫폼에서 사용가능한 도구를 선택하자.

### 내식대로 만들기
- AWS에 특정 태그이름을 추가하여 메타데이터를 추가하고 이를 통해 서비스를 찾는 방식을 사용할 수 있다.
- service = app1, environment = production, version = 1.0.0과 같은 방식으로 태그를 추가하여 서비스를 찾을 수 있다.
- AWS API를 통해 서비스를 찾을 수 있으며 이를 통해 서비스를 찾을 수 있다.
- 다운 스트림 서비스의 위치가 변경될 때 업스트림에게 알려주는 방식은 직접 구현해야한다.

## 서비스 매시와 API 게이트웨이
![img.png](../images/서비스매쉬%20예시.png)
- API 게이트웨이는 클라이언트와 서비스 사이에 위치하며 클라이언트의 요청을 받아서 서비스로 전달하는 역할을 한다.
- 서비스 매시는 서비스 간의 통신을 관리하는 방식이다.

### API 게이트웨이
- API 게이트웨이는 클라이언ㅜ트와 서비스 사이에 위치하며 클라이언트의 요청을 받아서 서비스로 전달하는 역할을 한다.
- API 키, 로깅, 서킷 브레이크 등과 같은 매커니즘을 구현하는데 사용
- GUI를 통해 관리할 수 있도록 많은 제품이 존재한다.
- 쿠버네티스는 기본적으로 클러스터 내부에서 네트워킹을 처리하고 외부와의 통신은 처리하지 않기 때문에 어떤 형식으로든 API 게이트 웨이가 필요하다.

#### 적용 대상
- 리버스 프록시: 쿠버네티스에서 실행되는 마이크로 서비스를 노출하기 위해 사용
- 관심사에 따라 분리된 API 게이트웨이: 서비스 디스커버리, 로깅, 인증, 인가, 서킷 브레이크 등의 관심사를 분리하기 위해 사용

#### 회피 대상
- 경계 외부가 아니라 경계 내부에서 사용하는 경우
- 핵심 비지니스 로직을 서드파티의 API 게이트웨이에 넣는 경우
- 파이프라인은 멍청하게 유지하고 엔드포인트는 똑똑하게 유지하는 것을 위반하지 말자
- API 게이트웨이에 유입된 동작이 많을수록 인수인계 비용이 높아지며 처리속도의 저하가 발생할 수 있다.
- 모든 마이크로서비스의 호출간 중계자로 사용하지 말자


## 서비스 매쉬
- 서비스 매시를 사용하면 마이크로서비스 간 통신과 관련된 공통 기능들이 매쉬로 관리된다.
- 이는 내부적으로 구현해야되는 기능들을 줄이고 일관성있는 통신을 보장할 수 있다.
- 공통 라이브러리를 사용할 경우 모든 서비스가 같은 버전을 사용해야되는데 서비스 매쉬를 사용하면 이러한 문제를 해결할 수 있다.

### 작동 방식
![img.png](../images/서비스%20매쉬.png)
- 내부적으로는 프록시를 사용하여 통신을 관리하고 이를 통해 서비스 간의 통신을 관리한다.
- 컨트롤 플레인을 통해 로컬 매시 프록시 위에 존재하며 프록시 동작을 변경하고 작업에 대한 정보를 수집한다.

### 매쉬의 오해와 진실
- 매쉬의 공통 동작은 마이크로 서비스의 국한되지 않은 동작을 관리하는 것이다.(인증서 관리, 타임아웃 등)
- 매쉬는 대규모의 마이크로 서비스를 관리하기 위한 것이기 때문에 작은 규모의 마이크로 서비스에서는 사용하여 복잡성을 증가시킬 필요는 없다.
- 비교적 최근의 기술이기 때문에 사용하는 것에 대한 리스크가 존재한다.

### 다른 프로토콜 사용
- API 게이트웨이와 서비스 매쉬는 HTTP 프로토콜을 사용하여 REST, SOAP, gRPC 등을 사용할 수 있다.
- 카프카와 같은 메시지 브로커를 사용하면 서비스 매쉬의 일관적인 공용 기능을 보장하기 어렵다.

## 서비스 문서화
- 서로 외부에 노출하고 있는 서비스의 인터페이스를 문서화하는 것은 매우 중요하다.
- API에 대한 문서화는 항상 최신 상태로 유지해야하며 이를 통해 사용자가 쉽게 사용할 수 있도록 해야한다.

### 명시적 스키마
- 사용자가 엔드포인트를 잘 사용하도록 가이드를 제공해주는 문서는 꼭 필요하다.
- 이런 가이드 문서가 명시적 스키마를 정의하고 관리하는데에는 도움이 되지 않고 실제 다른 인터페이스로 인해 오히려 사용자가 혼란스러워질 수 있다.
- 명시적 스키마를 사용하면 사용자가 쉽게 사용할 수 있도록 도와줄 수 있다.
  예시
- OpenAPI
- AsyncAPI
- CloudEvents

### 자기 기술 시스템
- 대규모의 조직에서 마이크로 서비스를 운영할 때에는 시스템의 상황과 작동 방식을 이해하는 것은 중요하다.
- Open API와 같은 도구는 어떤 엔드포인트에 어떤 기능이 호스팅되고 있는지 알 수 있도록 도와준다.
- 상태 확인 시스템이나 모니터링 툴은 서비스의 상태를 확인하는데 도움을 준다.
- 이러한 시스템의 변경을 단순히 위키로 문서화하는 것이 아니라 프로그래밍으로 관리하여 거대한 휴먼 레지스트리를 만들어 사용자가 쉽게 사용할 수 있도록 도와준다.


#### 예시
- 비즈옵스
- 백스테이지

#### 참조
https://martinfowler.com/bliki/HumaneRegistry.html

## 요약
- 해결하려는 문제가 기술의 선택지 기준이 되어야 한다. 기술이 먼저 선택되는 것은 좋지 않다.
- 어떤 선택을 하든 명시적인 스키마를 사용하여 문서화를 하는 것이 중요하다.
- 하위 호환되는 변경을 적용하여 독립적인 배포를 유지하여라
- 하위 호환이 깨지는 경우 소비자가 변경할 수 있는 시간을 제공하여 락스텝 배포를 피해라.
- 엔드포인트에 대한 정보들을 정리하기 위한 전략들을 고민해보자
